<!--TO READ THIS HELP FILE, RIGHT-CLICK ON THE FILE NAME IN THE
    SOLUTION EXPLORER PANE AND SELECT "VIEW IN BROWSER"-->

<html><head><title>DLLHUSK Sample: Dynamically Links the MFC Library</title></head><body><h1>DLLHUSK Sample: Dynamically Links the MFC Library</h1><div id="mainSection"><div id="mainBody"><div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()"></div><p /><p>The DLLHUSK sample dynamically links the MFC library to applications and custom dynamic-link libraries (DLL) sharing the same class library code, thus reducing the total memory required by running multiple applications.</p><p>Dynamically linking to MFC also offers other possible application architectures in which part of the application is implemented in a custom DLL, and both the application and the custom DLL share the MFC DLL (Mfcxx.dll). A custom DLL that shares framework functionality with an application is called an MFC extension DLL. </p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Security Note </th></tr><tr><td><p>This sample code is provided to illustrate a concept and should not be used in applications or Web sites, as it may not illustrate the safest coding practices.</p></td></tr></table></div><h1 class="heading">Building and Running the Sample</h1><div id="sectionSection0" class="seeAlsoNoToggleSection"><h4 class="subHeading">To build and run the DLLHUSK sample</h4><div class="subSection"><ol><li><p>Open the solution dllhusk.sln. </p></li><li><p>On the <b>Build</b> menu, click <b>Build</b>. </p></li><li><p>On the <b>Debug</b> menu, click <b>Start Without Debugging</b>. </p></li></ol></div><p>The DLLHUSK solution builds both the Dllhusk.exe application and the two DLLs (TESTDLL1.DLL and TESTDLL2.DLL) to which the application is dynamically linked. DLLHUSK requires MFCxx.DLL or MFCxxD.DLL at run time. These DLLs are installed by default in the Windows system directory.</p></div><h1 class="heading">DLLHUSK MFC Extension DLLs</h1><div id="sectionSection1" class="seeAlsoNoToggleSection"><p>DLLHUSK demonstrates MFC extension DLLs with class exports. C++ classes in the DLLs (Testdll1.dll and Testdll2.dll) are exported using the AFX_EXT_CLASS macro. The first MFC Extension DLL (TESTDLL1) is one in which all C++ class interfaces of the custom DLL are accessed only by the framework, not directly by the application. The custom DLL exports only <b>extern</b> "C" functions to the application. The custom DLL does not need to export the functions of classes derived from framework classes. All calls from the framework to derived classes in the custom DLL are resolved via the C++ virtual function mechanism.</p><p>The second MFC Extension DLL (TESTDLL2) is one in which some C++ class interfaces of the custom DLL are exported to and accessed directly by the application. </p><sections ><h4 class="subHeading" xmlns="">Testdll1.dll</h4><div class="subSection" xmlns=""><p>Testdll1.dll provides the implementation for DLLHUSK's document and view classes for both document types — the TEXT document type and the HELLO document type. The Dllhusk.exe implements the MDI frame window class, and the framework implements the multiple document interface (MDI) child window class (<b>CMDIChildWnd</b>). Two document template objects establish the associations among <code>CTextDoc</code>, <b>CMDIChildWnd</b>, and <b>CEditView</b> and among <code>CDummyDoc</code>, <b>CMDIChildWnd</b>, and <code>CHelloView</code>. DLLHUSK therefore illustrates that the framework can coordinate the relationships among framework-defined objects, even though the classes for those objects are implemented in the application, the custom (MFC extension) DLL, and the framework's Mfcxx.dll.</p><p>TESTDLL1 actually calls the application object's <b>AddDocTemplate</b> member function twice to register the two document template objects. It does so in the implementation of TESTDLL1's <code>InitTestDLL1</code> function, which is the only function that TESTDLL1 exports. This function is declared with <b>extern</b> "C" so that the DLLHUSK application can call it as a stand-alone C function. </p><p>The Testdll1.h header file (added as a <code>#include</code> by Dllhusk.cpp) includes not only the declaration of <code>InitTestDLL1,</code> but also the declarations of TESTDLL1's classes. Dllhusk.cpp refers directly to only the <code>InitTestDLL1</code> function. Indirectly, however, DLLHUSK uses the document and view classes implemented in Testdll1.dll.</p></div><h4 class="subHeading" xmlns="">Testdll2.dll</h4><div class="subSection" xmlns=""><p>Testdll2.dll provides the implementation for DLLHUSK's <b>CListOutputFrame</b> class. When the user chooses a diagnostic command by using the shortcut menu, the application creates a <b>CListOutputFrame</b> object and then sends diagnostic messages to the List Output window by calling <b>CListOutputFrame::AddString</b>.</p><p>All public member functions of<b> CListOutputFrame</b> are exported in the Testdll2.def file. The exports include not only <code>AddString</code> but also the public <b>CListOutputFrame</b> constructor and destructor. </p><p>It is more difficult to implement an MFC extension DLL that exports class member functions than one that exports only C functions. This is true particularly because you must manually add the C++ name-decorated function exports to the DLL's .def file. A technique for doing so is explained in <MSHelp:link keywords="B6F1080B-B66B-4B1E-8FB1-926C5816392C" tabindex="0" >Technical Note 33</MSHelp:link>.</p></div></sections></div><h1 class="heading">Additional DLLHUSK Features</h1><div id="sectionSection2" class="seeAlsoNoToggleSection"><p>DLLHUSK also illustrates:  </p><ul><li><p>Splitting resources for a single application into multiple .rc files, which can be edited in the Visual C++ resource editor.</p></li><li><p>Using two global diagnostic functions, <b>AfxDoForAllClasses</b> and <b>AfxDoForAllObjects</b>.</p></li><li><p>Enumerating <b>CDynLinkLibrary</b> objects.</p></li></ul></div><h1 class="heading">Keywords</h1><div id="sectionSection3" class="seeAlsoNoToggleSection"><p>This sample demonstrates the following keywords:</p><p>AfxDoForAllClasses; AfxDoForAllObjects; AfxGetApp; AfxGetResourceHandle; AfxMessageBox; AfxSetResourceHandle; AfxThrowMemoryException; CCmdUI::SetCheck; CColorDialog::DoModal; CColorDialog::GetColor; CDC::DrawText; CDC::SetBkColor; CDC::SetTextColor; CDialogBar::Create; CDocTemplate::GetDocString; CEditView::SerializeRaw; CFrameWnd::LoadFrame; CListBox::AddString; CListBox::Create; CListBox::GetCount; CListBox::GetText; CListBox::GetTextLen; CListBox::ResetContent; CListBox::SetCurSel; CMDIChildWnd::Create; CMenu::GetSubMenu; CMenu::LoadMenu; CMenu::TrackPopupMenu; CObject::AssertValid; CObject::Dump; CObject::Serialize; CStatusBar::Create; CStatusBar::SetIndicators; CToolBar::Create; CToolBar::LoadBitmap; CToolBar::SetButtons; CView::OnDraw; CWinApp::AddDocTemplate; CWinApp::InitInstance; CWinApp::LoadStdProfileSettings; CWinApp::OnFileNew; CWinApp::OpenDocumentFile; CWnd::GetClientRect; CWnd::GetCurrentMessage; CWnd::GetFont; CWnd::Invalidate; CWnd::OnCreate; CWnd::OnNcRButtonDown; CWnd::OpenClipboard; CWnd::SetFont; CWnd::ShowWindow; CWnd::UpdateWindow; CloseClipboard; EmptyClipboard; GetModuleFileName; GetSysColor; GlobalAlloc; GlobalLock; LOWORD; RGB; SetClipboardData; lstrlen; wsprintf</p><div class="alert"><table width="100%" cellspacing="0" cellpadding="0"><tr><th align="left">Note </th></tr><tr><td><p>Some samples, such as this one, have not been modified to reflect the changes in the Visual C++ wizards, libraries, and compiler, but still demonstrate how to complete your desired task. </p></td></tr></table></div></div></div><div id="footer"><div class="footerLine"></div>
          © Microsoft Corporation. All rights reserved.  Send <a href="mailto:DevDocs@microsoft.com?subject=Documentation Feedback :DLLHUSK Sample: Dynamically Links the MFC Library">comments</a> about this topic to Microsoft.
      </div></div></body></html>
